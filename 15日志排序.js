// 题目描述
// 运维工程师采集到某产品线网运行一天产生的日志n条，现需根据日志时间先后顺序对日志进行排序，日志时间格式为H:M:S.N。

// H表示小时(0~23)
// M表示分钟(0~59)
// S表示秒(0~59)
// N表示毫秒(0~999)
// 时间可能并没有补全，也就是说，01:01:01.001也可能表示为1:1:1.1。


// 输入描述
// 第一行输入一个整数n表示日志条数，1<=n<=100000，接下来n行输入n个时间。

// 输出描述
// 按时间升序排序之后的时间，如果有两个时间表示的时间相同，则保持输入顺序。

// 用例
// 输入	
// 2
// 01:41:8.9
// 1:1:09.211

// 输出	
// 1:1:09.211

// 01:41:8.9

// 说明	无
// 输入	
// 3
// 23:41:08.023
// 1:1:09.211
// 08:01:22.0

// 输出	
// 1:1:09.211

// 08:01:22.0

// 23:41:08.023

// 说明	无
// 输入	
// 2
// 22:41:08.023
// 22:41:08.23

// 输出	
// 22:41:08.023

// 22:41:08.23

// 说明	两个时间表示的时间相同，保持输入顺序
// 题目解析
// 排序日志时间用到的知识是：

// 将字符串时间中各要素提取出来（正则捕获组），然后计算出总毫秒数
// 根据Array.prototype.sort自定义排序策略，来算出的总毫秒数进行排序
// 2023.08.15 优化

// 将字符串时间中各要素提取出来，其实可以简单地按照 ":" 和 "." 进行分割，这里可以使用正则 [:.] ，作为分隔符。

const rl = require("readline").createInterface({
  input: process.stdin
});
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;
void async function () {
  const num = await readline()
  const time_arr = []
  const time = []
  for (let i = 0; i < num; i++) {
    time_arr.push(await readline())
  }
  time_arr.map((v) => {
    let h = v.split(/[:.]/).map(Number)
    let ms = h[0] * 60 * 60 * 1000 + h[1] * 60 * 1000 + h[2] * 1000 + h[3]
    time.push([ms, v])
  })
  time.sort((a, b) => a[0] - b[0])
  time.map(v => {
    console.log(v[1]);
  })

}()