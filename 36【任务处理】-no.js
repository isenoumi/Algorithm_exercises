// 题目描述
// 在某个项目中有多个任务（用task数组表示）需要你进行处理，其中：

// task[i] = [si, ei]
// 你可以在 si ≤ day ≤ ei 中的任意一天处理该任务，请返回你可以处理的最大任务数。

// 输入描述
// 第一行为任务数量 n

// 1 ≤ n ≤ 100000
// 后面 n 行表示各个任务的开始时间和终止时间，使用 si，ei 表示

// 1 ≤ si ≤ ei ≤ 100000
// 输出描述
// 输出为一个整数，表示可以处理的最大任务数。

// 用例
// 输入	3
// 1 1
// 1 2
// 1 3
// 输出	3
// 说明	无
// 题目解析
// 本题可以利用贪心思维+优先队列来求解。

// 我们可以将所有任务时间区间按照：优先按照结束时间降序，如果结束时间相同，则按照开始时间降序。这样排序的原因如下：

// 首先，任务优先按照结束时间降序后，那么第一个任务的结束时间就是最晚的（最大的），此时我们可以让第一个任务就在最晚时刻执行，如下面例子：

// 3
// 1 4
// 2 3
// 1 2

// 按照结束时间降序后：[1,4] , [2, 3],  [1, 2] ，第一个任务[1,4]在时刻4执行



// 这样做的好处是，避免第一个任务抢夺后面任务的执行时间，如下图所示：

// 如果第一个任务在时刻4执行，则第二个任务就有两个选择，时刻2或时刻3


// 如果第一个任务在时刻3执行，则第二个任务就只有一个选择，只能在时刻2执行


// 如果存在多个任务的结束时间都相同的话，则还需要对这些任务按照开始时间降序，这么做的原因是：

// "时间长" 的任务 "可选执行时刻" 多
// "时间短" 的任务 "可选执行时刻" 少
// 因此应该优先让时间跨度短的任务先执行，如下图所示：

// 如果优先时间短的任务，则三个任务都能执行


// 如果优先时间长的任务，则只能执行两个任务


// 但是上面逻辑是存在问题的，请看下面图示：

// 此时按照前面逻辑的话，只能执行三个任务



// 但是其实可以执行四个任务，执行策略如下：



// 主要问题是，当我们按照结束时间降序后，第一个任务选择时刻8执行完，此时后面三个任务的截止时间其实都是相同的，变为了时刻7。



// 因此，此时我们应该对后面三个任务重新按照时间跨度降序，再优先执行短的任务。

// 本题数量级较大，因此如果每次执行完一个任务，都对剩余任务进行更新结束时间，并重新排序的话，会超时。

// 改进策略是，使用优先队列，即：

// 如果当前任务的结束时间end >= 上一个任务的执行时刻last_end，则更新当前任务的结束为last_end - 1。如果 last_end - 1 > 当前任务开始时间start，则将当前任务重新入队排优先级。否则当前任务不可执行。

// Java和Python有内置的优先队列类，而JS和C没有，因此JS和C需要手动实现一个优先队列，关于优先队列的实现原理请看：

// LeetCode - 1705 吃苹果的最大数目-CSDN博客